# -*- coding: utf-8 -*-
"""ПЗ_1_2: РАБОТА С ФАЙЛАМИ ТЕКСТОВОГО ФОРМАТА.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ki_3yFLCcN4iJucXp0c066GNf7FWlqld

# Цель работы:
изучение основных функций *Python* при работе с текстовыми файлами и получения практических навыков.

В результате выполнения работы студент должен:
*   изучить популярные форматы текстовых файлов;
*   научится создавать данные, записывать в текстовый файл, считывать из текстовые файлы;
*   формализовывать данные, приводить их к единому формату с помощью методов пакетов Python.

# Теоретические сведения
Текстовый файл представляет из себя последовательность символов (в основном, печатных знаков, принадлежащих тому или иному набору символов). Эти символы обычно сгруппированы в строки (англ. *lines, rows*). В современных системах строки разделяются разделителями строк. Иногда конец текстового файла (особенно если в файловой системе не хранится информация о размере файла) также отмечается одним или более специальными знаками, известными как маркеры конца файла.

Текстовой файл может содержать как форматированный, так и неформатированный текст.

Наиболее распространеные форматы *текстовых* файлов:
*   **ТХТ** («*простой текстовый*») - это универсальный формат. Сохраняет текст без форматирования, в текст вставляются только управляющие символы *конца абзаца*. Так как текст хранится в виде последовательности символов, то размер файла в байтах равен числу символов плюс непечатаемые символы (знак пробела, табуляции, знак конца абзаца и другие - их ещё называют знаками форматирования). За счёт этого достигается малый размер файла. Однако возможности по форматированию подобных документов сильно ограничены. Применяют этот формат для хранения документов, которые должны быть прочитаны в приложениях, работающих в различных операционных системах.
*   **RTF** («*RichTextFormat*» - «*формат обогащённого текста*») - это свободный межплатформенный формат хранения размеченных текстовых документов, созданный Microsoft в 1987 году. Создав RTF на платформе Windows, он прекрасно будет читаться и редактироваться на других платформах (Apple, Linux и другие). Стандарт де-факто в полиграфии. Формат RTF позволяет производить и сохранять достаточно сложное форматирование, вставлять сноски, колонтитулы, рисунки, таблицы и формулы, хотя в этом он все же уступает формату DOC. Уступает он DOC и в объёме файлов: сложные документы более компактно хранятся в DOC-файлах (простые - наоборот).
*   **DOC** (от англ. «*document*») - этот формат ассоциируется только с продуктами Microsoft, обеспечивает большие возможности по форматированию текста (включены сценарии, макросы). За счёт этого ухудшилась совместимость с текстовыми редакторами сторонних разработчиков. Однако при включении в документ различных графических элементов и изображений DOC выигрывает в размере и обеспечивает большую совместимость. В отличие от ТХТ и RTF, DOC является *бинарным форматом*, что делает его нечитабельным в простых текстовых редакторах.
*   **DOCX**. С появлением Office 2007 компания Microsoft перешла на новые форматы, базирующиеся на OfficeOpen XML. Формат представляет собой **zip**-архив, содержащий текст в виде XML, графику и другие данные. Для уменьшения размера файла используется ZiP-компрессия.

*   **ODT/ODF** («*OpenDocumentFormat*») ODF - общее наименование открытого формата документов для офисных приложений (текст, таблицы, рисунки, базы данных, презентации). Текстовые данные хранятся в файлах с расширением ODT. Стандарт был разработан индустриальным сообществом OASIS и основан на XML-формате. Бесплатная альтернатива закрытым форматам Microsoft. Документы могут читаться офисным пакетом MicrosoftOffice версии 2007 и выше.
*   **HTML** (от англ. *HypertextMarkupLanguage* - «*язык разметки гипертекста*») - стандартный язык разметки документов в интернете (расширение .htm/html). Веб-страницы создаются при помощи языка HTML (или XHTML).
*   **PDF** (*PortableDocumentFormat* - «*переносимый формат документов*») - это кроссплатформенный формат электронных документов. В первую очередь предназначен для представления в электронном виде полиграфической продукции. Традиционным способом создания PDF-документов является следующий: документ как таковой готовится в своей программе, а затем экспортируется в PDF. Стандарт де-факто для большинства документации.
*   **DjVu** (*«дежавю»*) - формат использует технологию сжатия изображений "с потерями. Разработан специально для хранения сканированных документов - книг, журналов, рукописей и пр., где наличие формул, схем, рисунков и рукописных символов делает чрезвычайно трудоёмким их полноценное распознавание. Суть технологии DjVu заключается в автоматическом разбиении изображения на несколько участков (например, текст, логотип фирмы и растровая фотография), для каждого из которых выбирается оптимальный алгоритм сжатия.  
*   **XML**-форматы (*extensibleMarkupLanguage* - «*расширяемый язык разметки*») Существует довольно много текстовых форматов, созданных для одного конкретного устройства или программы. Например, электронные книги. К ним можно отнести Rocket e-book (.rb), MicrosoftReader (.lit), PalmDoc, MobiPocket (.pro) и т.д. Как правило, все они созданы с помощью языка XML. *FictionBook* (FB2) - формат представления электронных версий книг в виде XML-документов. Стандарт призван обеспечить совместимость с любыми устройствами и форматами. Его основным преимуществом является возможность создавать книги из файлов всех популярных текстовых форматов (*.txt, *.doc, *.rtf. *.html и пр.).

# Практическая часть
1. Работа с текстовыми файлами

Для формирования шаблонных данных, необходимо подключить библиотеку *NumPy*.
"""

# Commented out IPython magic to ensure Python compatibility.
# Подключение необходимых библиотек
import pandas as pd
from numpy import random
import matplotlib.pyplot as plt
import sys

# %matplotlib inline

print("Python version",sys.version)
print("Pandas version",pd.__version__)

"""2. Создание данных

Набор данных будет состоять из 1000 имен и количества рожденных детей с таким именем в России в 2015 году. Мы будем дублировать имена, чтобы одно и то же имя можно было встретить несколько раз.
"""

# Начальный набор данных
names = ['Саша', 'Маша', 'Гоша', 'Тоша', 'Антоша']

"""Создадим набор данных, состоящий из 1000 имен, при помощи следующих функций:
1.   seed(500) – создает начальное заполнение генератора случайных чисел.
2.   randint(low=0,high=len(names)) - генерируется случайное целое число от 0 до 4;
3.   names[n] – получаем значение по индексу *n* из набора names;
4.   foriinrange(n) – цикл по *n* элементам с шагом 1;
5.   random_names[:n]- созданная нами функция, возвращающая  *n* случайных имен.
"""

random.seed(500)
random_names = [names[random.randint(low=0,high=len(names))] for i in range(1000)]

# Вывод на экран первых 10 имен
random_names[:10]

"""Далее, создадим набор из 10 случайных чисел от 0 до 1000."""

births = [random.randint(low=0,high=1000) for i in range(1000)]
births[:10]

"""Объединим наборы с именами и числами с помощью функции *zip*()."""

BabyDataSet = list(zip(random_names,births))
BabyDataSet[:10]

"""Итак, набор данных готов.

Теперь, используя библиотеку *pandas*, экспортируем эти данные в текстовый файл. Предварительно, создадим объект *DataFrame*, который будет содержать созданный нами набор данных.
"""

df = pd.DataFrame(data = BabyDataSet, columns=['Names', 'Births'])
df[:10]

"""Экспортируем полученную таблицу в текстовый файл *births2015.txt*. Функция **to_csv** позволит экспортировать наши данные в файл и сохранит его в каталоге с выполняющим скриптом.
Если назначим параметрам **index** (индекс) и **header** (заголовок) значение *False* — индексы и заголовки не сохранятся в файл.
"""

df.to_csv('births2015.txt',index=False,header=False, encoding="utf8")

"""3. Получение данных

Для того, чтобы прочитать сохраненные на предыдущем шаге данные, воспользуемся функцией **read_csv**. Передадим ей расположение текстового файла.
"""

Location = r'births2015.txt'
df = pd.read_csv(Location)
df.info()

"""Расшифровка:
*   имеется 999 записей с 2 полями в каждой;
*   в поле «Гоша» содержатся 999 значений (мы разберемся с этим позже);
*   в поле «968» содержатся 999 значений;
*   одно из полей является числовым, другое - не числовое.

Чтобы отобразить содержимое набора данных, необходимо воспользоваться функцией **head**(), которая по умолчанию возвращает первые пять записей в наборе. Передаваемый в скобках параметр, позволит получить указанное количество значений.
"""

df.head()

"""Очевидно, что функция **read_csv** определила первую строку данных, как заголовки набора. Это неправильно, и чтобы это исправить, нужно передать в параметр **header** функции **read_csv** значение *None*."""

df = pd.read_csv(Location, header=None)
df.info()

"""Расшифровка:

*    в наборе содержатся 1000 записей;
*    в поле «0» содержатся 1000 значений;
*    в поле «1» содержатся 1000 значений;
*    типы данных в полях: числовой и объектный.
Выведем последние пять записей таблицы при помощи функции **tail**().
"""

df.tail()

"""Так же можно назвать столбцы конкретными именами добавив их имена в параметр **names**."""

df = pd.read_csv(Location, names=['Names','Births'])
df.head(5)

"""Для удаления текстового файла можно воспользоваться процедурой **remove**() из библиотеки **os**."""

import os
os.remove(Location)

"""4. Выборка данных

Найти  количество уникальных значений  в поле **Names** можно *двумя* способами.

Способ_1: заключается в использовании функции **unique**().
"""

df['Names'].unique()

"""Для вывода значений на экран можно пройтись циклом по полученному массиву и выводить значения с помощью конструкции print:"""

# Вывод на экран уникальных значений
for x in df['Names'].unique():
  print(x)

"""Способ_2:"""

print(df['Names'].describe())

"""Для того чтобы сгруппировать количество рожденных детей по имени, можно воспользоваться функцией **groupby**()."""

# Создание объекта группировки по полю Names
name = df.groupby('Names')
# Применение функцию суммирования к сгруппированному набору
df = name.sum()
df

"""5. Анализ данных

Чтобы найти самое популярное имя среди детей, рожденных в 2015 году, необходимо определить наибольший показатель рождаемости. Для этого используем процедуру **max**().
"""

# Способ_1:
Sorted = df.sort_values(by='Births', ascending=False)
Sorted.head(1)

# Способ_2:
df['Births'].max()

"""6. Представление данных

По значениям столбца **Births** можно построить график при помощи функции **plot**(), чтобы графически было видно самую высокую точку рождаемости. По графику и отсортированной таблице можно определить, что Саша - самое
популярное имя в наборе.
"""

# Создание графика
df['Births'].plot(kind='bar')
print("Самое популярное имя:" )
df.sort_values(by='Births', ascending=False)

"""7. Сведения о наборе данных

Для просмотра сведений о наборе данных, можно воспользоваться функцией **info**() объекта **DataFrame**. Сведения включают в себя список полей, и количество непустых значений в каждом из них.

Полезно: этот набор данных охватывают все запросы на обслуживание, такие как брошенные автомобили, ремонт парковочных счетчиков и вывоз крупногабаритного мусора.
"""

complaints = pd.read_csv('311_City_Service_Requests_in_2026.csv')
complaints.info()

complaints.head()

"""8. Выборка полей и строк

Для того, чтобы выбрать определенное поле, необходимо указать его имя в качестве индекса над объектом **DataFrame**.
"""

complaints['STREETADDRESS']

"""Для того чтобы получить пять первых строк набора, нужно сделать срез  по данным **df[:5]**.Также можно объединить запросы и получить первые пять значений поля."""

complaints['STREETADDRESS'][:5]

"""9. Выбор нескольких полей

Для получения информации по нескольким полям, необходимо указать их названия, как индекс набора данных и использовать **info**().
"""

complaints[['CITY', 'STREETADDRESS']].info()

"""Для того, чтобы посмотреть значения первых десяти строк, нужно сделать срез по 10 элементам."""

complaints[['CITY', 'STREETADDRESS']][:10]

"""10. Выборка строк по условию

***Задание***:

найти самый распространенный вид запросы на обслуживание из указанного набора ('3311_City_Service_Requests_in_2026.csv'). Для начала посчитаем количество запросов каждого вида с помощью функции **value_counts**().
"""

complaints['SERVICECODEDESCRIPTION'].value_counts()

"""Для того чтобы выбрать 10 самых распространенных видов услу, сделаем срез из полученного набора."""

complaint_counts = complaints['SERVICECODEDESCRIPTION'].value_counts()
complaint_counts[:10]

"""Выбранную информацию отразим на графике."""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
complaint_counts[:10].plot(kind='bar')