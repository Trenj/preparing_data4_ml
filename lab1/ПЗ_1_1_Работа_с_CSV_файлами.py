# -*- coding: utf-8 -*-
"""ПЗ_1_1: РАБОТА С CSV-ФАЙЛАМИ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wqmPGfSakphK_QOtXiI7wtx6O6uJrjL6

# Цель работы:
познакомить студента с форматом хранения данных .csv и изучить функции Python для работы с данным форматом представления данных.

В результате выполнения работы студент должен:
*   знать формат файлов.csv.;
*   уметь работать с файлами такого формата (считывать и записывать данные);
*   уметь строить графики по данным из формата .csv.

# Теоретические сведения
Файл в формате **CSV** (*comma-separatedvalues* - значения, разделенные запятыми) - текстовая структура данных, предназначенная для переноса табличной информации между приложениями (электронными таблицами, СУБД, адресными книгами и т.п.).

Каждая строка файла представляет собой запись, каждое поле которой отделено от другого ***символом-разделителем*** (чаще всего - запятой).

Внутри файл выглядит примерно так:

name,number,text

a,1,something here

b,2,"one, two, three"

c,3,"no commas here"

Для работы с **CSV**-файлами необходимо подключить библиотеку *pandas*.

Для вывода полученных данных в таблицу, также необходимо подключить библиотеку *Matplotlib*.

# Практическая часть
1. Создание данных

Первым шагом в выполнении практической работы будет подключение всех необходимых библиотек.
"""

# Commented out IPython magic to ensure Python compatibility.
# Подключение отдельной функции из библиотеки
# from (имя_библиотеки) import (имя_функции)
from pandas import DataFrame, read_csv

# Общий синтаксис подключения библиотек без функций:
# import (имя_библиотеки) as (псевдоним)
import matplotlib.pyplot as plt
import pandas as pd
import sys # Строка нужна для того, чтобы определить версию Python

# Подключение inline-режима для построения графиков
# %matplotlib inline

# Вывод на экран версии python
print('Python version',sys.version)

# Вывод на экран версии pandas
print('Pandas version ',pd.__version__)

# Commented out IPython magic to ensure Python compatibility.
# Подключение отдельной функции из библиотеки
# from (имя_библиотеки) import (имя_функции)
from pandas import DataFrame, read_csv

# Общий синтаксис подключения библиотек без функций:
# import (имя_библиотеки) as (псевдоним)
import matplotlib.pyplot as plt
import pandas as pd
import sys # Строка нужна для того, чтобы определить версию Python

# Подключение inline-режима для построения графиков
# %matplotlib inline

# Вывод на экран версии python
print('Python version',sys.version)

# Вывод на экран версии pandas
print('Pandas version ',pd.__version__)

# Commented out IPython magic to ensure Python compatibility.
# Подключение отдельной функции из библиотеки
# from (имя_библиотеки) import (имя_функции)
from pandas import DataFrame, read_csv

# Общий синтаксис подключения библиотек без функций:
# import (имя_библиотеки) as (псевдоним)
import matplotlib.pyplot as plt
import pandas as pd
import sys # Строка нужна для того, чтобы определить версию Python

# Подключение inline-режима для построения графиков
# %matplotlib inline

# Вывод на экран версии python
print('Python version',sys.version)

# Вывод на экран версии pandas
print('Pandas version ',pd.__version__)

"""После подключения библиотек, необходимо создать *набор данных*. К примеру, он будет состоять из **пяти** имен и **количества** рожденных детей с таким именем в России в 2015 году."""

# Начальный набор данных
names = ['Саша', 'Маша', 'Гоша', 'Тоша', 'Антоша']
births = [968, 155, 77, 578, 973]

# Объеденим оба списка
BabyDataSet = list(zip(names,births))
print(BabyDataSet)

# Импорт данных в CSV-файл
df = pd.DataFrame(data = BabyDataSet, columns=['Names', 'Births'])
# df - это объект DataFrame, т.е. проиндексированный многомерный массив значений. По аналогии схож с таблицей SQL или таблицей Excel.
df

"""Экспортируем полученную таблицу в **CSV**-файл и назовем его *births2015.csv*.

Функция **to_csv** позволит экспортировать данные в файл и сохранит его. Файл будет сохранен в корне каталога компилятора *Python*. Если назначить параметрам **index** (индекс) и **header** (заголовок) значение *False*, то они НЕ сохранятся в файле.
"""

df.to_csv ("births2015.csv", index = False, header = False, encoding="utf8")

"""2. Получение данных

Чтобы вновь воспользоваться сохраненными данными в **CSV**-файле воспользуемся функцией "*read_csv*". Более подробно почитать про эту функцию можно набрав в интерпретаторе команду *read_csv*.

Примечание:

Путь зависит, от того, где сохранен файл. Символ **r** в начале строки предупреждает компилятор о том, что специальные символы такие как «/» всего лишь текст.
"""

Location = r"births2015.csv"
df = pd.read_csv(Location)
df

"""После вывода данных, прочитанных из **CSV**-файла, на экран, появится проблема в правильности наименования заголовков, т.к. в конкретном примере у таблицы их быть не должно. Чтобы это исправить, передадим в параметр **header** функции *read_csv* значение **None**, т.е. явным образом убираем информацию в заголовках."""

df = pd.read_csv(Location, header=None)
df

"""Для того чтобы называть столбцы конкретными именами, добавим их имена в параметр *names*."""

df = pd.read_csv(Location, names=['Names','Births'])
df

"""Можно предположить, что индексы [0, 1, 2, 3, 4] подобны строками в *Excel*, однако для библиотеки *pandas* они представляют собой часть индекса выбранного набора данных. Эти индексы нельзя использовать в **SQL**-запросах в виде первичного ключа, потому что индексы могут дублироваться.

[Names, Births] - это названия столбцов, аналогично заголовкам электронных таблиц в *Excel*.

После загрузки набора данных в память компьютера, можно удалить исходный **CSV**-файл.
"""

import os
os.remove(Location)

"""3. Подготовка данных

На предыдущем этапе, мы получили набор с данными, состоящего из имен и количества рожденных детей с этими именами. Рассмотрим эти данные более подробно.  

В колонке **Names** записаны имена в *алфавитно-цифровом виде*, т.е. там могут быть различные символы.

Колонка **Births** должна содержать только целые числа. Необходимо проверить все ли данные из этой колонки целые числа или нет.  
"""

# Проверка типа данных столбцов
df.dtypes

# Проверка типа данных столбца Births
df.Births.dtype

"""Так как столбец **Births** имеет тип данных *int64*, тип данных изменять не нужно и это удовлетворяет поставленному условию.

4. Анализ данных

Для того чтобы найти самое популярное имя среди детей, рожденных в 2015 году, необходимо определить наибольший показатель **Births**. Это можно сделать двумя способами:
1.   Отсортировать набор данных по убыванию значений в выбранном поле и выбрать первую строку.
2.   Воспользоваться процедурой *max*(), возвращающей максимальное значение в наборе, над нужным полем.
"""

# Способ_1
Sorted = df.sort_values(by='Births', ascending=False)
Sorted.head(1)

# Способ_2
df['Births'].max()

"""5. Представление данных

По значениям столбца **Births** можно построить график, чтобы графически было видно самую высокую точку рождаемости. В сочетании с таблицей пользователь будет точно знать, что «Антоша» самое популярное имя в **DataFrame**.

На предыдущем шаге мы получили максимальное значение поля. Теперь, чтобы найти соответствующее этому значению имя необходимо провести выборку, но для начала разберем некоторые полезные части кода:
*   df['Names'] – список всех имен;
*   df['Births'] – список значений в поле «количество рождений»;
*   df['Births'].max() – это максимальное значение находящееся в поле «количество рождений»;
*   [df['Births'] == df[‘Births'].max()] – эквивалентно запросу: найти все записи в поле «количество рождений», где его значение равно максимальному;
*   df['Names'][df['Births'] == df['Births'].max()] – запрос вернет все записи в поле Names, где значение в поле Births равно максимальному значению в выбранном наборе данных.   
"""

# можно получить значение имени из созданного ранее набора «Sorted»
Sorted['Names'].head(1).values[0]

"""Используемая далее функция *str*() преобразует входящий объект в строку."""

# Установка шрифта (без засечек), поддерживающего кириллицу
plt.rc('font', family='sans-serif')

# Создание графика
df['Births'].plot()

# Максимальное значение в наборе данных
MaxValue = df['Births'].max()

# Имя, связанное с максимальным значением
MaxName = df['Names'][df['Births'] == df['Births'].max()].values

# Текст отображающийся на графике
Text = str(MaxValue) + " - " + MaxName

# Добавление текста на график
plt.annotate(Text, xy=(1, MaxValue), xytext=(8, 0), xycoords=('axes fraction', 'data'), textcoords='offset points')

print ("Самое популярное имя:" )
df[df['Births'] == df['Births'].max()]

"""6.  Чтение данных из **CSV**-файла

Чтобы получить данные из **CSV**-файла  необходимо использовать функцию *read_csv*. В качестве источника данных для анализа возьмем набор данных велосипедных дорожек Монреаля за 2012 год в виде csv (загрузить по ссылке:
https://github.com/jvns/pandas-cookbook/blob/v0.1/data/bikes.csv).
"""

broken_df = pd.read_csv('bikes.csv')
# Просмотр первых трех строк таблицы
broken_df[:3]

"""Как видно из полученного результата, данные из **CSV**-файла, не всегда могут быть корректно прочитаны без дополнительных настроек. Однако указание правильных значений атрибутов функции *read_csv* позволяет это исправить.

Для этого необходимо проделать ряд изменений:
*   установить разделителем полей символ «точка с запятой»;
*   поменять кодировку на *latin1* (изначально **utf-8**);
*   разобрать дату из поля *«Date»*;
*   привести дату к виду год-месяц-число;
*   назначить поле с датой в качестве индекса.
"""

fixed_df = pd.read_csv('bikes.csv', sep=';',
                        encoding='latin1',
                        parse_dates=['Date'],
                        dayfirst=True,
                        index_col='Date')
fixed_df[:3]

"""6.1. Выборка столбца

При считывании данных из **CSV**-файла  получаем объект *DataFrame*, который состоит из строк и столбцов. Из этого объекта можно осуществлять выборку столбцов.
"""

fixed_df['Berri 1']

"""6.2. Построение графика

Для построения графика *выбранного* столбца воспользуемся функцией *plot*().
"""

fixed_df['Berri 1'].plot()

"""Также можно представить в виде графика *все* столбцы набора."""

fixed_df.plot(figsize=(15, 10))